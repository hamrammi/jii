<!DOCTYPE html>
<html>
<head>
  <title>Test base `jii` methods with `Jasmine`</title>
  <meta charset="utf-8">
  <script type="text/javascript" src="../src/jii.js"></script>
  <link rel="stylesheet" type="text/css" href="jasmine/jasmine.css">
  <script type="text/javascript" src="jasmine/jasmine.js"></script>
  <script type="text/javascript" src="jasmine/jasmine-html.js"></script>

  <script type="text/javascript">

    describe('jii.capitalize', function() {
      it('should return capitalized string', function() {
        expect(jii.capitalize('nemo')).toBe('Nemo');
      });

      it('should return four capitalized letters', function() {
        expect(jii.capitalize('squirrel', 4)).toBe('SQUIrrel');
      });
    });

    describe('jii.swapCase', function() {
      it('should return string with swapped letter cases', function() {
        expect(jii.swapCase('NoRtH')).toBe('nOrTh');
      });
    });

    describe('jii.isUpperCased', function() {
      it('should report that string is uppercased', function() {
        expect(jii.isUpperCased('GOLLUM')).toBe(true);
      });

      it('should report that string is not uppercased', function() {
        expect(jii.isUpperCased('Gollum')).toBe(false);
      });
    });

    describe('jii.isLowerCased', function() {
      it('should report that string is uppercased', function() {
        expect(jii.isLowerCased('gOllUm')).toBe(false);
      });

      it('should report that string is not uppercased', function() {
        expect(jii.isLowerCased('gollum')).toBe(true);
      });
    });

//    describe('jii.toUnicode', function() {
//      it('should transform string to unicode format', function() {
//        expect(jii.toUnicode('Mordor')).('\u004d\u006f\u0072\u0064\u006f\u0072');
//      });
//    });
//
//    describe('jii.toCharCode', function() {
//      it('should transform letters of string to char codes', function() {
//        expect(jii.toCharCode('Mordor')).toEqual("\x4d\x6f\x72\x64\x6f\x72");
//      });
//    });

    describe('jii.endsWith', function() {
      it('should return last letter `d` of the word `wind`', function() {
        expect(jii.endsWith('wind')).toBe('d');
      });

      it('should return last 4 letters `ic` of the word `magic`', function() {
        expect(jii.endsWith('magic', 4)).toBe('agic');
      });

      it('should throw an exception', function() {
        expect(function() { jii.endsWith('magic', 7); }).toThrow(
            Error('"jii.endsWith" says: "string length exceeded"')
        );
      });

      it('should throw an exception', function() {
        expect(function() { jii.endsWith('magic', 3, true); }).toThrow(
            Error('"jii.endsWith": expected "string", got "number"')
        );
      });

      it('should check that `mystery` ends with `ery`', function() {
        expect(jii.endsWith('mystery', 'ery')).toBe(true);
      });

      it('should check that `mystery` does not end with `very`', function() {
        expect(jii.endsWith('mystery', 'very')).toBe(false);
      });

      it('should check that `mystery` does not end with `Ery`', function() {
        expect(jii.endsWith('mystery', 'Ery')).toBe(false);
      });

      it('should check that `mystery` ends with `ErY` with `caseInsensitive` argument', function() {
        expect(jii.endsWith('mystery', 'ErY', true)).toBe(true);
      });
    });

    describe('jii.startsWith', function() {
      it('should return first letter `w` of the word `wind`', function() {
        expect(jii.startsWith('wind')).toBe('w');
      });

      it('should return first 4 letters `magi` of the word `magic`', function() {
        expect(jii.startsWith('magic', 4)).toBe('magi');
      });

      it('should throw an exception', function() {
        expect(function() { jii.startsWith('magic', 7); }).toThrow(
            Error('"jii.startsWith" says: "string length exceeded"')
        );
      });

      it('should throw an exception', function() {
        expect(function() { jii.startsWith('magic', 3, true); }).toThrow(
            Error('"jii.startsWith": expected "string", got "number"')
        );
      });

      it('should check that `mystery` starts with `myst`', function() {
        expect(jii.startsWith('mystery', 'myst')).toBe(true);
      });

      it('should check that `Mystery` starts with `Myst`', function() {
        expect(jii.startsWith('Mystery', 'Myst')).toBe(true);
      });

      it('should check that `mystery` does not start with `lyst`', function() {
        expect(jii.startsWith('mystery', 'lyst')).toBe(false);
      });

      it('should check that `mystery` does not start with `Myst`', function() {
        expect(jii.startsWith('mystery', 'Myst')).toBe(false);
      });

      it('should check that `mystery` starts with `MySt` with `caseInsensitive` argument', function() {
        expect(jii.startsWith('mystery', 'MySt', true)).toBe(true);
      });
    });

    describe('jii.positions', function() {
      it('should return array of indexes of letter `a` in the word `Malachai`', function() {
        expect(jii.positions('Malachai', 'a')).toEqual([1, 3, 6]);
      });

      it('should return empty array since there is no letter `o` in the word `Malachai`', function() {
        expect(jii.positions('Malachai', 'o')).toEqual([]);
      });
    });

    describe('jii.reverse', function() {
      it('should return reversed string', function() {
        expect(jii.reverse('Morgoth')).toBe('htogroM');
        expect(jii.reverse('MorgoTh')).toBe('hTogroM');
        expect(jii.reverse('MoRgoTh')).toBe('hTogRoM');
      });
    });

    describe('jii.trim', function() {
      it('should trim left space(s)', function() {
        expect(jii.trim(' On the left', 'left')).toBe('On the left');
        expect(jii.trim('          On the left', 'left')).toBe('On the left');
      });

      it('should trim right space(s)', function() {
        expect(jii.trim(' On the right    ', 'right')).toBe(' On the right');
        expect(jii.trim('On the right       ', 'right')).toBe('On the right');
      });

      it('should trim left and right space(s)', function() {
        expect(jii.trim('  Both  ')).toBe('Both');
        expect(jii.trim('       Both sides   ')).toBe('Both sides');
        expect(jii.trim('     Both  sides   ')).toBe('Both  sides');
      });

      it('should trim both left and right space(s) and leave only one space between words', function() {
        expect(jii.trim('   One two   three    ', 'full')).toBe('One two three');
        expect(jii.trim('   One two   three    ', 'full')).not.toBe('One   two three');
      });
    });

    describe('jii.title', function() {
      it('should capitalize each word in a string', function() {
        expect(jii.title('a new hope')).toBe('A New Hope');
      });
    });

    describe('jii.similar', function() {
      it('should report that arrays are similar', function() {
        expect(jii.similar([1, 2, 3, 4], [4, 3, 2, 1])).toBe(true);
        expect(jii.similar([4, 2, 1, 4], [2, 3, 4, 1])).toBe(true);
        expect(jii.similar(
            [{ a: 'foo', b: function() {} }, true, [], this],
            [true, this, { a: 'foo', b: function() {} }, []]
        )).toBe(true);
        expect(jii.similar(
            [
              { a: 'foo', m: { null: undefined },
                b: function() {},
                c: [
                  { null: null, r: [undefined, [['foo']], 'this'] },
                  [[[[[[[[[1, [[[true, [[, function() { return true; }, [[[[[[[], undefined]]]]]], 'u']]]]]]]]]]]]]]
                ]
              },
              true,
              [{a: { f: undefined, m: null, g: 'foobar' }}, [[[[]], 'missing']]],
              this
            ],
            [
              { a: 'foo', m: { null: undefined },
                b: function() {},
                c: [
                  { null: null, r: [undefined, [['foo']], 'this'] },
                  [[[[[[[[[1, [[[true, [[, function() { return true; }, [[[[[[[], undefined]]]]]], 'u']]]]]]]]]]]]]]
                ]
              },
              true,
              [{a: { f: undefined, m: null, g: 'foobar' }}, [[[[]], 'missing']]],
              this
            ]
        )).toBe(true);
        expect(jii.similar(
            [
              { a: 'foo', m: { null: undefined },
                b: function() {},
                c: [
                  { b: 'b' },
                  [1, 2, [[[[4]]]]]
                ]
              },
              true,
              [{a: { f: undefined, m: null, g: 'foobar' }}, [[[[]], 'missing']]],
              this
            ],
            [
              { a: 'foo', m: { null: undefined },
                b: function() {},
                c: [
                  { b: 'b' },
                  [1, 2, [[[[4]]]]]
                ]
              },
              true,
              [{a: { f: undefined, m: null, g: 'foobar' }}, [[[[]], 'missing']]],
              this
            ]
        )).toBe(true);
      });
      it('should report that arrays are not similar', function() {
        expect(jii.similar(
            [true, this, {}, ['new']],
            [this, {}, true, ['new'], { a: null }]
        )).toBe(false);
        expect(jii.similar(
            [true, this, {}, ['new'], { a: null }],
            [this, {}, true, ['new']]
        )).toBe(false);
      });
    });

    describe('jii.max', function() {
      it('should return max element `199`', function() {
        expect(jii.max([4, 23, 56, 199, 32, 89])).toEqual(199);
      });

      it('should return the most long word: `Approximately`', function() {
        expect(jii.max(['North', 'Approximately', 'Sea', 'Wolf'])).toEqual('Approximately');
      });
    });

    describe('jii.min', function() {
      it('should return min element `4`', function() {
        expect(jii.min([4, 23, 56, 199, 32, 89])).toEqual(4);
      });

      it('should return the most short word: `Sea`', function() {
        expect(jii.min(['North', 'Approximately', 'Sea', 'Wolf'])).toEqual('Sea');
      });
    });

    describe('jii.zip', function() {
      it('should zip two arrays', function() {
        var a = [23, 'sd', true, 'bar', false, 564],
            b = ['ds', 234, false, '96', undefined, 3],
            c = [[23, 'ds'], ['sd', 234], [true, false], ['bar', '96'],
                 [false, undefined], [564, 3]];
        expect(jii.zip(a, b)).toEqual(c);
      });
    });

    describe('jii.map', function() {
      it('should map the array', function() {
        expect(jii.map([1, 2, 3, 4], function(x) {
          return x * x;
        })).toEqual([1, 4, 9, 16]);
      });
    });

    describe('jii.hasChain', function() {
      var o = {
        foo: {
          bar: 'bar',
          baz: 'baz'
        },
        bar: {
          quux: {
            bar: [true, false],
            baz: {},
            foo: ''
          },
          baz: false,
          foo: []
        }
      };
      it('should return string "bar"', function() {
        expect(jii.hasChain(o, 'foo.bar')).toEqual('bar');
      });
      it('should return `false`', function() {
        expect(jii.hasChain(o, 'bar.baz')).toEqual(false);
      });
      it('should return `true`', function() {
        expect(jii.hasChain(o, 'bar.quux.baz')).toEqual({});
      });
      it('should return empty string', function() {
        expect(jii.hasChain(o, 'bar.quux.foo')).toEqual('');
      });
      it('should check whether it is falsy or truthy`', function() {
        expect(jii.hasChain(o, 'bar.quux.baz')).toBeTruthy();
        expect(jii.hasChain(o, 'bar.quux.baz')).not.toBeFalsy();
        expect(jii.hasChain(o, 'bar.foo')).toBeTruthy();
        expect(jii.hasChain(o, 'bar.foo')).not.toBeFalsy();
        expect(jii.hasChain(o, 'bar.quux.foo')).toBeFalsy();
      });
    });

    (function() {
      var jasmineEnv = jasmine.getEnv();
      jasmineEnv.updateInterval = 250;

      var htmlReporter = new jasmine.HtmlReporter();
      jasmineEnv.addReporter(htmlReporter);

      jasmineEnv.specFilter = function(spec) {
        return htmlReporter.specFilter(spec);
      };

      var currentWindowOnload = window.onload;
      window.onload = function() {
        if (currentWindowOnload) {
          currentWindowOnload();
        }
        execJasmine();
      };

      function execJasmine() {
        jasmineEnv.execute();
      }
    })();

  </script>
</head>
<body>
</body>
</html>